{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cryptography","text":"","tags":["Cryptography"]},{"location":"#introduction","title":"Introduction","text":"<p>Cryptography is the process of hiding or coding information so that only the person a message was intended for can read it. The art of cryptography has been used to code messages for thousands of years and continues to be used in bank cards, computer passwords, and ecommerce.</p> <p></p>","tags":["Cryptography"]},{"location":"#what-is-cryptography","title":"What is Cryptography?","text":"<p>Cryptography is the science of providing security and protection of information. It is used everywhere in our digital world: when you open a Web site, send an email or connect to the WiFi network. That's why developers should have at least basic understanding of cryptography and how to use crypto algorithms and crypto libraries, to understand hashing, symmetric and asymmetric ciphers and encryption schemes, as well as digital signatures and the cryptosystems and algorithms behind them.</p>","tags":["Cryptography"]},{"location":"#what-does-cryptography-solve","title":"What does Cryptography solve?","text":"<p>Cryptographic methods try to protect for confidentiality, authenticity, and integrity:</p> <ul> <li>Confidentiality is hiding sensitive information to other people.</li> <li>Integrity is protecting the data from unauthorized changes.</li> <li>Authenticity is proving who you are.</li> </ul> <p></p>","tags":["Cryptography"]},{"location":"#modern-cryptography","title":"Modern Cryptography","text":"<p>Cryptography has evolved from its first attempts (thousands years ago), through the first successful cryptographic algorithms for developers (like the now retired MD5 and DES) to modern crypto algorithms (like SHA-3, Argon2 and ChaCha20).</p> <p>Key components of cryptography are:</p> <ul> <li>Data: content to be secured(encrypted)</li> <li>Algorithm: the computational method to encrypt the data</li> <li>Key: the element needed in order to encrypt/decrypt the data successfully. Also it can be used for validation purposes.</li> </ul> <p>The contemporary ways that uses cryptography are:</p> <ul> <li>Hashing: A hash function is any function that can be used to map data of arbitrary size to fixed-size values. The values returned by a hash function are called hash values, hash codes, digests, or simply hashes. Common use cases are hash functions (SHA-256, SHA3, RIPEMD and others), HMAC (hashed message authentication code), password to key derivation functions (like Scrypt), the Diffie-Hellman key-exchange protocol</li> <li>Symmetric-key encryption: In Symmetric-key encryption the message is encrypted by using a single key and the same key is used to decrypt the message which makes it easy to use but less secure. It also requires a safe method to transfer the key from one party to another. The most common scheme used is AES cipher with CBC and CTR block modes.</li> <li>Asymmetric-key encryption: Asymmetric key encryption is one of the most common cryptographic methods that involve using a single key and its pendent, where one key is used to encrypt data and the second one is used to decrypt an encrypted text. The second key is kept highly secret, while the first one which is called a public key can be freely distributed among the service\u2019s users. Asymmetric keys most common encryption schemes are the RSA cipher and elliptic curves-based cryptography (ECC), with the secp256k1 curve and the Ed25519 cryptosystem.</li> <li>Digital signatures and ECDSA, as well as the concept of entropy and secure random number generation and quantum-safe cryptography.</li> </ul> <p></p>","tags":["Cryptography"]},{"location":"#encryption-and-keys","title":"Encryption and Keys","text":"<p>Cryptography deals with storing and transmitting data in a secure way, such that only those, for whom it is intended, can read and process it. This may involve encrypting and decrypting data using symmetric or asymmetric encryption schemes, where one or more keys are used to transform data from plain to encrypted form and back.</p> <p>Symmetric encryption (like AES, Twofish and ChaCha20) uses the same key to encrypt and decrypt messages, while asymmetric encryption uses a public-key cryptosystem (like RSA or ECC) and a key-pair: public key (encryption key) and corresponding private key (decryption key). Encryption algorithms are often combined in encryption schemes (like AES-256-CTR-HMAC-SHA-256, ChaCha20-Poly1305 or ECIES-secp256k1-AES-128-GCM).</p> <p>Cryptography deals with keys (large secret numbers) and in many scenarios these keys are derived from numbers, passwords or passphrases using key derivation algorithms (like PBKDF2 and Scrypt).</p>","tags":["Cryptography"]},{"location":"#digital-signatures-and-message-authentication","title":"Digital Signatures and Message Authentication","text":"<p>Cryptography provides means of digital signing of messages which guarantee message authenticity, integrity and non-repudiation. Most digital signature algorithms (like DSA, ECDSA and EdDSA) use asymmetric key pair (private and public key): the message is signed by the private key and the signature is verified by the corresponding public key. In the bank systems digital signatures are used to sign and approve payments. In blockchain signed transactions allow users to transfer a blockchain asset from one address to another.</p> <p>Cryptography deals with message authentication algorithms (like HMAC) and message authentication codes (MAC codes) to prove message authenticity, integrity and authorship. Authentication is used side by side with encryption, to ensure secure communication.</p>","tags":["Cryptography"]},{"location":"#secure-random-numbers","title":"Secure Random Numbers","text":"<p>Cryptography uses random numbers and deals with entropy (unpredictable randomness) and secure generation of random numbers (e.g. using CSPRNG). Secure random numbers are unpredictable by nature and developers should care about them, because broken random generator means compromised or hacked system or app.</p>","tags":["Cryptography"]},{"location":"#key-exchange","title":"Key Exchange","text":"<p>Cryptography defines key-exchange algorithms (like Diffie-Hellman key exchange and ECDH) and key establishment schemes, used to securely establish encryption keys between two parties that intend to transmit messages securely using encryption. Such algorithms are performed typically when a new secure connection between two parties is established, e.g. when you open a modern Web site or connect to the WiFi network.</p>","tags":["Cryptography"]},{"location":"#cryptographic-hashes-and-password-hashing","title":"Cryptographic Hashes and Password Hashing","text":"<p>Cryptography provides cryptographic hash functions (like SHA-3 and BLAKE2), which transform messages to message digest (hash of fixed length), which cannot be reversed back to the original message and almost uniquely identifies the input. In blockchain systems, for example, hashes are used to generate blockchain addresses, transaction ID and in many other algorithms and protocols. In Git cryptographic hashes are used for generating unique ID for files and commits.</p> <p>Password hashing and password to key derivation functions (like Scrypt and Argon2) protect user passwords and password encrypted documents and data by securely deriving a hash (or key) from a text-based passwords, injecting random parameters (salt) and using a lot of iterations and computing resources to make password cracking slow.</p>","tags":["Cryptography"]},{"location":"#confusion-and-diffusion-in-cryptography","title":"Confusion and Diffusion in Cryptography","text":"<p>In cryptography the hashing, encryption algorithms and random generators follow the Shannon's principles of confusion and diffusion. Confusion means that each bit in the output form a cipher should depend on several parts of the key and input data and thus direct mapping cannot be established. Diffusion means that changing one bit in the input should change approximately half of the bits in the output. These principles are incorporated in most hash functions, MAC algorithms, random number generators, symmetric and asymmetric ciphers.</p>","tags":["Cryptography"]},{"location":"#cryptographic-libraries","title":"Cryptographic Libraries","text":"<p>Developers should know the modern cryptographic libraries for their programming language and platform and how to use them. Developing with cryptography requires understanding of the crypto-concepts. Copy / pasting code from Internet or following an example from a blog may lead to insecure design and weak security. Cryptographic libraries are very useful, but you should understand the concepts first, then choose appropriate combination of algorithms and adjust carefully their parameters.</p>","tags":["Cryptography"]},{"location":"#quantum-resistant-cryptography","title":"Quantum-Resistant Cryptography","text":"<p>Fortunately, researchers have been working to develop public-key algorithms that could resist code-breaking efforts from quantum computers, preserving or restoring trust in certificate authorities, digital signatures, and encrypted messages.</p> <p>Notably, the U.S. National Institute of Standards and Technology is already evaluating 69 potential new methods for what it calls \u201cpost\u2013quantum cryptography.\u201d The organization expects to have a draft standard by 2024, if not before, which would then be added to web browsers and other internet applications and systems.</p> <p>In principle, symmetric cryptography can be used for key exchange. But this approach depends on the security of trusted third parties to protect secret keys, and it cannot implement digital signatures, so it would be difficult to apply across the internet. Still, it is used throughout the Global System for Mobile Communication (GSM) cellular standard for encryption and authentication.</p> <p>Another alternative to public-key cryptography for key exchange is quantum key-distribution. Here, quantum methods are used by the sender and receiver to establish a symmetric key. But these methods require special hardware.</p>","tags":["Cryptography"]},{"location":"asymmetric/","title":"Asymmetric Cryptopgraphy","text":"<p>Before introducing the asymmetric key encryption schemes and algorithms, we should first understand the concept of public key cryptography (asymmetric cryptography).</p> <p>The public key cryptography uses a different key to encrypt and decrypt data (or to sign and verify messages). Keys always come as public + private key pairs. Asymmetric cryptography deals with encrypting and decrypting messages using a public / private key, signing messages, verifying signatures and securely exchanging keys.</p> <p></p> <p>Popular public-key cryptosystems (asymmetric crypto algorithms) like RSA (Rivest\u2013Shamir\u2013Adleman), ECC (elliptic curve cryptography), Diffie-Hellman, ECDH, ECDSA and EdDSA, are widely used in the modern cryptography and we shall demonstrate most of them in practice with code examples.</p> <p></p> <p>Asymmetric encryption is slower and less efficient than symmetric encryption, but it is more secure for certain applications, such as secure communication over the internet.</p> <p></p>","tags":["asymmetric"]},{"location":"asymmetric/#key-pairs","title":"Key Pairs","text":"<p>Asymmetric encryption schemes use a pair of cryptographically related public and private keys to encrypt the data (by the public key) and decrypt the encrypted data back to its original forms (by the private key). Data encrypted by a public key is decrypted by the corresponding private key.</p> <p>The encrypted data, obtained as result of encryption is called ciphertext. The ciphertext is a binary sequence, unreadable by humans and by design cannot be decrypted without the decryption key.</p> <p>Note</p> <p>Public key encryption can work also in the opposite scenario: encrypt data by a private key and decrypt it by the public key. Thus someone can prove that he is owner of certain private key, while revealing only its corresponding public key. This approach is used by some digital signature schemes.</p> <p>In some public key cryptosystems (like the Elliptic-Curve Cryptography - ECC), the public key can be calculated from the private key. In other cryptosystems (like RSA), the public key and the private key are generated together but cannot be directly calculated from each other.</p> <p>Usually, a public / private key pair is randomly generated in a secure environment (e.g. in a hardware wallet) and the public key is revealed, while the private key is securely stored in a crypto-wallet and is protected by a password or by multi-factor authentication.</p> <p>Example of 256-bit private key and its corresponding 256-bit public key (based on secp256k1 curve):</p> <pre><code>privKey: 648fc1fa828c7f185d825c04a5b21af9e473b867eeee1acea4dbab938433e158\npubKey: 02c324648931b89e3e8a0fc42c96e8e3be2e42812986573a40d46563bceaf75110\n</code></pre>","tags":["asymmetric"]},{"location":"asymmetric/#private-keys","title":"Private Keys","text":"<p>Message decryption and signing is done by a private key. The private keys are always kept secret by their owner, just like passwords. In the server infrastructure, private key usually stay in an encrypted and protected keystore. In the blockchain systems the private keys usually stay in specific software or hardware apps or devices called \"crypto wallets\", which store securely a set of private keys.</p> <p>Example of 256-bit private key:</p> <pre><code>648fc1fa828c7f185d825c04a5b21af9e473b867eeee1acea4dbab938433e158\n</code></pre>","tags":["asymmetric"]},{"location":"asymmetric/#public-keys","title":"Public Keys","text":"<p>Message encryption and signature verification is done by the public key. Public keys are by design public information (not a secret). It is mathematically infeasible to calculate the private key from its corresponding public key.</p> <p>In many systems the public key is encapsulated in a digital certificate, which binds certain identity (e.g. person or Internet domain name) to certain public key. In blockchain systems public keys are usually published as parts of the blockchain transactions to help identify who has signed each transaction. In systems like PGP and SSH the public key is downloaded from the server once (after manual user verification) and is remembered for further use.</p> <p>Example of 256-bit public key:</p> <pre><code>02c324648931b89e3e8a0fc42c96e8e3be2e42812986573a40d46563bceaf75110\n</code></pre> <p>In most blockchain systems the blockchain address is derived from the public key (by hashing and other transformations), so if you have someone's public key, you are assumed to have his blockchain address as well.</p> <p>A certain public key can be connected to certain person or organization or is used anonymously. You can never know who is the owner of the private key, corresponding to certain public key, unless you have additional proof, e.g. a digital certificate.</p>","tags":["asymmetric"]},{"location":"asymmetric/#cryptosystems","title":"Cryptosystems","text":"<p>Public key cryptosystems provide mathematical framework and algorithms to generate public + private key pairs, to sign, verify, encrypt and decrypt messages and exchange keys, in a cryptographically secure way.</p> <p>Well-known public-key cryptosystems are: RSA, ECC and ElGamal. Many crypto algorithms are based on the primitives from these cryptosystems like RSA sign, RSA encrypt / decrypt, ECDH key exchange and ECDSA and EdDSA signatures.</p>","tags":["asymmetric"]},{"location":"asymmetric/#rsa","title":"RSA","text":"<p>The RSA public-key cryptosystem is based on the math of modular exponentiations (numbers raised to a power by modulus) and some additional assumptions, together with the computational difficulty of the integer factorization problem. We shall discuss it later in details, along with examples.</p>","tags":["asymmetric"]},{"location":"asymmetric/#ecc","title":"ECC","text":"<p>The elliptic-curve cryptography (ECC) public-key cryptosystem is based on the math of the on the algebraic structure of the elliptic curves over finite fields and the difficulty of the elliptic curve discrete logarithm problem (ECDLP). The ECC usually comes together with the ECDSA algorithm (elliptic-curve digital signature algorithm). We shall discuss ECC and ECDSA in details, along with examples.</p> <p>ECC uses smaller keys, ciphertexts and signatures than RSA and is recommended for most applications. It is mathematically proven that a 3072-bit RSA key has similar cryptographic strength to a 256-bit ECC key. Key generation is in ECC is significantly faster than with RSA.</p> <p>Due to the above reasons most blockchain networks (like Bitcoin and Ethereum) use elliptic-curve-based cryptography (ECC) to secure the transactions.</p> <p>Warning</p> <p>Both RSA and ECC cryptosystems are not quantum-safe, which means that if someone has enough powerful quantum computer, he will be able to derive the private key from given public key in just few seconds.</p>","tags":["asymmetric"]},{"location":"asymmetric/#encryptiondecryption","title":"Encryption/Decryption","text":"<p>Asymmetric encryption works for small messages only (limited by the public / private key length). To encrypt larger messages key encapsulation mechanisms or other techniques can be used, which encrypt asymmetrically a random secret key, then use it to symmetrically encrypt the larger messages. In practice, modern asymmetric encryption schemes involve using a symmetric encryption algorithm together with a public-key cryptosystem, key encapsulation and message authentication.</p> <p>Popular asymmetric encryption schemes are: RSA-OAEP (based on RSA and OAEP padding), RSAES-PKCS1-v1_5 (based on RSA and PKCS#1 v1.5 padding), DLIES (based on discrete logarithms and symmetric encryption) and ECIES (based on elliptic curve cryptography and symmetric encryption).</p>","tags":["asymmetric"]},{"location":"asymmetric/#key-encapsulation-mechanism-kem","title":"Key encapsulation mechanism (KEM)","text":"<p>Typically, public-key crypto systems can encrypt messages of limited length only and are slower than symmetric ciphers. For encrypting longer messages (e.g. PDF documents) usually a public-key encryption scheme (also known as hybrid encryption scheme) is used, which combines symmetric and asymmetric encryption</p> <p></p> <p>Key encapsulation mechanism (KEM): encapsulate an asymmetrically-encrypted random (ephemeral) symmetric key and use symmetric algorithm for the data encryption.</p> <ul> <li>For the encryption a random symmetric key <code>sk</code> is generated, the message is symmetrically encrypted by <code>sk</code>, then <code>sk</code> is asymmetrically encrypted using the recipient's public key.</li> <li>For decryption, first the <code>sk</code> key is asymmetrically decrypted using the recipient's private key, then the ciphertext is decrypted symmetrically using <code>sk</code>.</li> </ul>","tags":["asymmetric"]},{"location":"asymmetric/#asymmetric-vs-symmetric","title":"Asymmetric vs Symmetric","text":"<p>Symmetric and asymmetric encryption are two different types of encryption that are used in various applications. Symmetric is faster and more efficient, perfect for handling large amounts of data. On the other hand, asymmetric encoding offers greater security as parties do not need to exchange their secret keys.</p> <p>Note</p> <p>Asymmetric encryption is less common than symmetric encryption, but it is growing in popularity. It is used in applications where security is critical, such as online banking and cryptocurrency. The most popular asymmetric algorithm is the RSA algorithm, and RSA 2048 is the strongest asymmetric algorithm available.</p> <p>In order to decide wether using one type of another, here is a table with its main differences.</p> <p></p>","tags":["asymmetric"]},{"location":"asymmetric/#digital-signatures","title":"Digital Signatures","text":"<p>A digital signature is an unique and non-transferable electronic seal that links an individual or entity to a digital document or message. It works similarly to a traditional handwritten signature, but using advanced cryptographic techniques to ensure the authenticity, integrity and confidentiality of the information.</p> <ul> <li>Authentication, by serving as a credential to validate the identity of the entity that it is issued to.</li> <li>Encryption, for secure communication over insecure networks such as the internet.</li> <li>Integrity of documents signed with the certificate so that they cannot be altered by a third party in transit.</li> </ul> <p>Warning</p> <p>The legitimacy of digital signatures are dependent on the certificate that authenticates the content and the signer. There are various reputable and legitimate digital certifying authorities (CA) that allow companies to obtain digital certificates.</p> <p></p> <p>Digital signatures in short: a message can be signed by certain private key and the obtained signature can be later verified by the corresponding public key. A signed message cannot be altered after signing. A message signature proves that certain message (e.g. blockchain transaction) is created by the owner of certain public key.</p> <p>Note</p> <p>The digital document or message is not directly signed, instead a hash digest (i.e <code>SHA-256</code>) is calculated and used to generate the digital signature (encrypted). Both the original data and the digital signature are sent to the destination, so it can check if the data is valid by using the public key to decrypt.</p> <p></p> <p>Digital signatures are widely used in the finance industry for authorizing payments. In operating systems OS components and device drivers are usually digitally signed to avoid injecting insecure code, trojans or viruses in the OS. In blockchain systems, transactions are typically signed by the owner of certain blockchain address (which corresponds to certain public key and has corresponding private key). So a signed blockchain transaction holds a proof of authorship: it is guaranteed mathematically that the signature is created by the holder of certain blockchain address and the transaction was not modified after the signing. This works perfectly for the scenario of digital payments and digital signing of documents and contracts.</p> <p></p>","tags":["asymmetric"]},{"location":"asymmetric/#certificates","title":"Certificates","text":"<p>Certificates are often used as containers for asymmetric keys because they can contain more information such as expiry dates and issuers. There is no difference between the two mechanisms for the cryptographic algorithm, and no difference in strength given the same key length. Generally, you use a certificate to encrypt other types of encryption keys in a database, or to sign code modules.</p> <p>A certificate basically is a digitally signed security object that contains a public key (and optionally a private key) and additional content.</p>","tags":["asymmetric"]},{"location":"asymmetric/#types-and-formats","title":"Types and Formats","text":"<p>There are a few different types of certificate formats that can be used for digital certificates. The most common format is the <code>X.509</code> format, which is a standardized format that is often used for Internet security. Other formats include <code>PGP</code>, <code>OpenPGP</code>, and<code>S/MIME</code>. Each of these formats has its own advantages and disadvantages, so it\u2019s important to choose the right one for your needs.</p> <ul> <li>X.509 certificates: X.509 certificates are the most common type of digital certificate. They are often used for website security and for email encryption. X.509 certificates can be issued by either a trusted third party or by a company or organization.</li> <li>PGP and OpenPGP Certificates: PGP and OpenPGP are two other types of digital certificates. PGP is a proprietary format that is owned by Symantec. OpenPGP is an open standard that is managed by the IETF. S/MIME is another type of digital certificate that is often used for email encryption.</li> </ul> <p>There are several encoding formats and extensions in <code>X.509</code> certificate alone. You may have seen certificates in <code>.pem</code>, <code>.crt</code>, <code>.p7b</code>, <code>.der</code>, <code>.pfx</code>, and so many. If we ask if all the extensions are the same, the answer is both yes and no. All these certificates are the same but with different encoding standards. All that depends on the type of encoding your application, or operating system accepts.</p> <p></p>","tags":["asymmetric"]},{"location":"asymmetric/#certificate-authority","title":"Certificate Authority","text":"<p>A certificate authority (CA) is a trusted entity that issues a SSL/TLS certificates. These digital certificates are data files used to cryptographically link an entity with a public key. Web browsers use them to authenticate content sent from web servers, ensuring trust in content delivered online.</p> <p></p> <p>A certificate signing request (CSR) is sent to the certificate authority to obtain a digital certificate. A certificate can contain: Fully Qualified Domain Name (FQDN), Organization Name (ON), Organization Unit (OU), Country (C), City/State, email, etc.</p> <p>SSL/TLS certificates and other types of certificates follow a similar CSR process.</p> <ol> <li>The client generates a key pair with the private and the public key. The private key is stored securely by the client. Then it generates a CSR (<code>PKCS#10</code>) which contains the subject, the generated public key and additional attributes.</li> <li>Certificate Authority receives CSR and verifies the signature with the public key (Automatic Certificate Management Environment (ACME)). Then CA generates a Signed Server Certificate (<code>X.509</code>) by signing previous request with its own private key.</li> <li>Finally, CA sends the certificate and the certificate chain to the client.</li> </ol> <p></p> <p>There are two types of certificate authorities (CAs): root CAs and intermediate CAs. For an SSL certificate to be trusted, that certificate must have been issued by a CA that\u2019s included in the trusted store of the device that\u2019s connecting.</p> <p>If the certificate wasn\u2019t issued by a trusted CA, the connecting device (eg. a web browser) checks to see if the certificate of the issuing CA was issued by a trusted CA. It continues checking until either a trusted CA is found (at which point a trusted, secure connection will be established), or no trusted CA can be found (at which point the device will usually display an error).</p> <p>The list of SSL certificates, from the root certificate to the end-user certificate, represents the SSL certificate chain</p> <p></p>","tags":["asymmetric"]},{"location":"asymmetric/#ssltls","title":"SSL/TLS","text":"<p>The Open Systems Interconnection (OSI) model is a way to divide up the problem of communicating between two remote computers. The abstract model has seven layers, and each layer has certain functions that should be performed by the service at that layer. Further, each layer needs only know about the layer below it, and needs to only worry about providing reliable information to the layer above it.</p> <p>The Transmission Control Protocol/Internet Protocol (TCP/IP) model came before the OSI model. The key difference between TCP/IP and OSI model is that TCP/IP is a practical model that addresses specific communication challenges and relies on standardized protocols. In contrast, OSI serves as a comprehensive, protocol-independent framework designed to encompass various network communication methods.</p> <p>The SSL/TLS protocol operates on:</p> <ul> <li>Application / Presentation / Session layers of OSI model</li> <li>Application layer of TCP/IP model</li> </ul> <p></p> <p>SSL and TLS protocols allow to exchange secure information between to computers. They are responsible for the following three things:</p> <ul> <li>Confidentiality: it's impossible to spy on exchanged information. Client and server must have the insurance that their conversation can't be listened to by someone else. This is ensured by an encryption algorithm.</li> <li>Integrity: it's impossible to falsify exchanged information. A client and a server must ensure that transmitted messages are neither truncated nor modified (integrity), and that they come from an expected sender. These functionalities are done by signature of data.</li> <li>Authentication: it allows to be sure of the software identity, the person or corporation with which we communicate. Since SSL 3.0, the server can also ask the client to authenticate, ensured by the use of certificates.</li> </ul> <p>TLS and SSL protocols are based on a combination on both asymmetrical and symmetrical encryption.</p>","tags":["asymmetric"]},{"location":"asymmetric/#https","title":"HTTPS","text":"<p>Hypertext transfer protocol secure (HTTPS) is an encrypted version of HTTP. Which is the protocol used to transfer data between web browsers (like Chrome) and servers (computers that host websites). Conceptually, HTTP/TLS is very simple. Simply use HTTP over TLS precisely as you would use HTTP over TCP.</p> <ol> <li>Browser contacts website: The user's web browser attempts to connect to a website using HTTPS</li> <li>SSL certificate sends: The website's server responds by sending its SSL/TLS certificate to the browser. This certificate contains the website\u2019s public key (encryption key) and is used to establish a secure connection.</li> <li>Browser verifies certificate: The browser checks the certificate to ensure it\u2019s valid and is issued by a trusted certificate authority (like GoDaddy, DigiCert, Comodo, etc.). This step is crucial for confirming a website\u2019s authenticity.</li> <li>Encryption key exchange: The browser and the server establish an encrypted connection by exchanging keys once the certificate is verified. The browser uses the server's public key to encrypt information, which can only be decrypted by the private key (i.e., the decryption key) the server holds.</li> <li>Encrypted data transfer: All data transferred between the browser and the server is encrypted after the secure connection is established. Which ensures it can\u2019t be read by anyone intercepting the data.</li> <li>Data decryption and display: The server decrypts the received data using the private key, processes it, and sends back the requested information. This data is also encrypted. The browser then decrypts the incoming data and displays the website content to the user.</li> </ol> <p></p>","tags":["asymmetric"]},{"location":"hashing/","title":"Hashing","text":"<p>Hashing is NOT encryption. It is simply a fingerprint of the given input. However, it is a one-way transaction and as such it is almost impossible to reverse engineer a hash to retrieve the original string.</p> <p></p> <p>All Hashing functions share the following properties:</p> <ul> <li>One-way, it cannot be inferred the original value from the digest.</li> <li>Deterministic, so the same input will generate the same output (digest) every time the hash is computed.</li> <li>Uses fix size to generate the final digest: 64, 128, etc.. (the content could be any length)</li> <li>Pseudo Random: any change to the original content will generate a totally different digest.</li> </ul> <p></p>","tags":["hash","hashing","SHA-256","HMAC"]},{"location":"hashing/#algorithms","title":"Algorithms","text":"<p>Following are the most common algorithm that has been used for hashing:</p> <ul> <li>MD5 (Message-Digest Algorithm 5): It has been deprecated since it has Vulnerabilities, Weak security and Lack of collision resistance, due to the small size of the digest and the  creation of different inputs that produce the same hash value. This makes it unsuitable for applications that require data integrity or security.</li> <li>SHA-1 (Secure Hash Algorithm 1): The once-widely used algorithm is now easy to crack, making it unsafe to use in security contexts</li> <li>CRC-32: A cyclic redundancy check(CRC) is an error-detecting code often used for detection of accidental changes to data. These days, CRC32 is rarely used outside of Zip files.</li> <li>SHA-256: This algorithm is particularly suited for securing sensitive data due to its higher bit length and increased complexity.</li> </ul> <p></p>","tags":["hash","hashing","SHA-256","HMAC"]},{"location":"hashing/#sha-256","title":"SHA-256","text":"<p>SHA-256 calculates a 256-bit hash value for an input message of 512 bits. The real application may need to calculate the hash value for a very long message. In such cases, the message is divided into many 512-bit data blocks. If the last block is smaller than 512 bits, padding is added. The SHA-256 algorithm computes intermediate hash values for data blocks one by one, in which the hash result of the current block becomes the input initial hash for hash computing of the next data block. The result of the final data block is considered to be the hash value of the entire message.</p> <p></p> <p>SHA-256 algorithm provides a secure way to generate a hash digest with the enough complexity to avoid collisions.</p> <p></p>","tags":["hash","hashing","SHA-256","HMAC"]},{"location":"hashing/#applications","title":"Applications","text":"","tags":["hash","hashing","SHA-256","HMAC"]},{"location":"hashing/#password-verification","title":"Password verification","text":"<p>Storing all user passwords as cleartext can result in a massive security breach if the password file is compromised. One way to reduce this danger is to only store the hash digest of each password, so when the password is created, this is stored as a digest instead of storing the plain-text or encrypted data. When the user login again, the password is hashed again using the same algorithm and it's compared with the hash stored in the database in order to validated it.</p> <p></p> <p>Since the basic hash is deterministic it always generates the same output for the same input, this can the easily hacked using a rainbow table that store a list of most used passwords in order to perform a brute force attack.</p> <p></p> <p>Because of that a Random Salt technique is used to avoid this king of attack since in the database the password stored was generated using a salt that perform a transformation that change the digest totally from the original.</p> <p></p> <p>This is the store just the password digest directly into the database versus store the digest with the applied salt information.</p> <p></p> <p>In cryptography and cybersecurity, choosing a password hashing algorithm is crucial for protecting user credentials and sensitive data. There are multiple password hashing algorithm (bcrypt, Argon2, scrypt, and PBKDF2) with their strengths, weaknesses, use cases, and prospects so the algorithm to use depends on the scenario.</p>","tags":["hash","hashing","SHA-256","HMAC"]},{"location":"hashing/#bcrypt","title":"Bcrypt","text":"<p>Bcrypt is a password-hashing function designed by Niels Provos and David Mazi\u00e8res, based on the Blowfish cipher and presented at USENIX in 1999.[1] Besides incorporating a salt to protect against rainbow table attacks, bcrypt is an adaptive function over time, the iteration count can be increased to make it slower, so it remains resistant to brute-force search attacks even with increasing computation power.</p> <ul> <li>Adaptive function with a work factor that can be increased over time</li> <li>Built-in salt to protect against rainbow table attacks</li> <li>Relatively slow, which is beneficial for password-hashing</li> </ul>","tags":["hash","hashing","SHA-256","HMAC"]},{"location":"hashing/#pbkdf2","title":"PBKDF2","text":"<p>Password-Based Key Derivation Function 2 (PBKDF2) is part of RSA Laboratories' Public-Key Cryptography Standards (PKCS) series. It's widely used and considered a standard in many applications. PBKDF2 applies a pseudorandom function, such as hash-based message authentication code (HMAC), to the input password or passphrase along with a salt value and repeats the process many times to produce a derived key, which can then be used as a cryptographic key in subsequent operations. The added computational work makes password cracking much more difficult, and is known as key stretching.</p> <ul> <li>Applies a pseudorandom function to the input password along with a salt</li> <li>Uses key stretching through iteration count</li> <li>It can be used with various underlying cryptographic hash functions (e.g., SHA-256)</li> </ul> <p></p>","tags":["hash","hashing","SHA-256","HMAC"]},{"location":"hashing/#proof-of-work","title":"Proof-of-work","text":"<p>Proof of work is a consensus mechanism used to confirm that network participants calculate valid hashes to verify bitcoin transactions and add the next block to the blockchain. It does so by having other participants in the network verify that the required amount of computing power was used by the miner that is credited with calculating the valid hash. The more miners working to verify transactions (and the faster they can generate hashes), the higher a network's hash rate.</p> <p>This is an example of block mining, where the hash digest for the transaction block in order to be joined to the blockchain must start with <code>0000XX</code>. In order to find a proper hash digest that starts with <code>0000</code> the miner must add a value (nonce) that iterates over in order to find a proper digest.</p> <p></p>","tags":["hash","hashing","SHA-256","HMAC"]},{"location":"hashing/#hmac","title":"HMAC","text":"<p>Hash-based message authentication code (or HMAC) is a cryptographic authentication technique that uses a hash function (SHA-256) and a secret key. By using HMAC, you can achieve authentication and verify that data is correct and authentic with shared secrets, as opposed to approaches that use signatures and asymmetric cryptography.</p> <p></p> <p>It can be use to check if the message has been modified in the transit by somebody else.</p> <p></p>","tags":["hash","hashing","SHA-256","HMAC"]},{"location":"source/","title":"Source","text":"","tags":["Java","Cryptography"]},{"location":"source/#hashing","title":"Hashing","text":"","tags":["Java","Cryptography"]},{"location":"source/#sha-256","title":"SHA-256","text":"AES Mode<pre><code>    /**\n     * Hash algorithm. It's recommended to use SHA-256 over legacy (non-trusted) algorithms such as SHA-1 or MD5\n     */\n    public static final String DEFAULT_HASH_ALGORITHM = \"SHA-256\"; // [\"SHA-256\", \"SHA-1\", \"MD5\"]\n</code></pre> AES Encrypt<pre><code>    private HashUtils.HashData hash(final byte[] data) throws NoSuchAlgorithmException {\n        // Create Hash function to generate the digest using the specified algorithm.\n        final var messageDigest = MessageDigest.getInstance(DEFAULT_HASH_ALGORITHM);\n        final var hash = messageDigest.digest(data); // (1)!\n        return new HashUtils.HashData(data, hash, EncodeUtils.encode(hash));\n    }\n\n    private HashUtils.HashData hashWithSalt(final byte[] data, final byte[] salt) throws NoSuchAlgorithmException {\n        // Create Hash function to generate the digest using the specified algorithm.\n        final var messageDigest = MessageDigest.getInstance(DEFAULT_HASH_ALGORITHM);\n        messageDigest.update(salt); // (2)!\n        final var hash = messageDigest.digest(data); // (3)!\n        return new HashUtils.HashData(data, hash, EncodeUtils.encode(hash));\n    }\n</code></pre> <ol> <li>Compute the Hash directly using <code>SHA-256</code> algorithm.</li> <li>Apply a Salt to data before computing the Hash.</li> <li>Compute the Hash using <code>SHA-256</code> algorithm.</li> </ol>","tags":["Java","Cryptography"]},{"location":"source/#pbkdf2","title":"PBKDF2","text":"AES Mode<pre><code>    /**\n     * SHA-256 is not enough for password hashing even using salt that is the fundamental for password hashing.\n     * PBKDF2 applies a pseudorandom function, such as hash-based message authentication code (HMAC), to the\n     * input password or passphrase along with a salt value and repeats the process many times to produce a\n     * derived key, which can then be used as a cryptographic key in subsequent operations. The added computational\n     * work makes password cracking much more difficult, and is known as key stretching.\n     * PBKDF2, BCrypt, and SCrypt. BCrypt, and SCrypt does not ship with Java SDK by default\n     */\n    public static final String HASH_ALGORITHM = \"PBKDF2WithHmacSHA1\";\n\n    public static final int ITERATION_COUNT = 65536;\n\n    public static final int KEY_LENGTH = 128;\n</code></pre> AES Encrypt<pre><code>    private HashUtils.HashData hash(final String password, final byte[] salt) throws GeneralSecurityException {\n        final var spec = new PBEKeySpec(password.toCharArray(), salt, ITERATION_COUNT, KEY_LENGTH);\n        final var factory = SecretKeyFactory.getInstance(HASH_ALGORITHM);\n        byte[] hash = factory.generateSecret(spec).getEncoded();\n        return new HashUtils.HashData(password.getBytes(), hash, EncodeUtils.encode(hash));\n    }\n</code></pre>","tags":["Java","Cryptography"]},{"location":"source/#hmac","title":"HMAC","text":"AES Mode<pre><code>    /**\n     * HMAC is a cryptographic method that guarantees the integrity of the message between two parties.\n     * HMAC algorithm consists of a secret key and a hash function (SHA-256). The secret key is a unique piece\n     * of information or a string of characters. It is known both by the sender and the receiver of the message.\n     * The hash function is a mapping algorithm that converts one sequence to another sequence.\n     */\n    public static final String HASH_ALGORITHM = \"HmacSHA256\";\n</code></pre> AES Encrypt<pre><code>    private HashUtils.HashData hmac(final byte[] data, final byte[] key) throws GeneralSecurityException {\n        final var spec = new SecretKeySpec(key, HASH_ALGORITHM);\n        final var mac = Mac.getInstance(HASH_ALGORITHM);\n        mac.init(spec);\n        final var hmac = mac.doFinal(data);\n        return new HashUtils.HashData(data, hmac, EncodeUtils.encode(hmac));\n    }\n</code></pre>","tags":["Java","Cryptography"]},{"location":"source/#symmetric-key","title":"Symmetric Key","text":"Symmetric Key<pre><code>    /**\n     * The Advanced Encryption Standard (AES, Rijndael) is a block cipher encryption and decryption\n     * algorithm, the most used encryption algorithm in the worldwide. The AES processes block of 128\n     * bits using a secret key of 128, 192, or 256 bits.\n     */\n    public static final String AES = \"AES\";\n\n    /**\n     * For AES, the legal key sizes are 128, 192, and 256 bits.\n     */\n    public static final int AES_KEY_SIZE = 128;\n\n    /**\n     * The IV (initial value or initialization vector), it is random bytes, typically 12 bytes or 16 bytes\n     */\n    public static final int INITIALIZATION_VECTOR_SIZE = 16;\n\n\n    /**\n     * @return\n     * @throws GeneralSecurityException\n     */\n    public static SecretKey generateSymmetricKey() throws GeneralSecurityException {\n        // Get the Key Generator\n        final var keyGenerator = KeyGenerator.getInstance(AES);\n        // Init the AES Symmetric key using 128 bits\n        keyGenerator.init(AES_KEY_SIZE, SecureRandom.getInstanceStrong());\n        return keyGenerator.generateKey();\n    }\n\n\n    /**\n     * A cryptographic nonce is a randomly generated number designed to keep communications private and\n     * protect against replay attacks.\n     *\n     * @return\n     */\n    public static byte[] getRandomNonce() {\n        final var nonce = new byte[INITIALIZATION_VECTOR_SIZE];\n        new SecureRandom().nextBytes(nonce);\n        return nonce;\n    }\n</code></pre>","tags":["Java","Cryptography"]},{"location":"source/#aesebc-mode","title":"AES/EBC Mode","text":"AES Mode<pre><code>    /**\n     * AES + Electronic Code Book (ECB) + NoPadding\n     * ECB is the easiest block cipher way of functioning, since each block of input plaintext is directly encrypted,\n     * and the output is in the form of encrypted ciphertext blocks. In general, if a message is bigger than b bits\n     * in size, it can be divided into many blocks and the process repeated.\n     */\n    public static final String ENCRYPT_ALGORITHM = \"AES/ECB/NoPadding\";\n</code></pre> AES Encrypt<pre><code>    private byte[] encrypt(final byte[] data, final SecretKey secretkey)\n        throws GeneralSecurityException {\n        final var encryptionCipher = Cipher.getInstance(ENCRYPT_ALGORITHM);\n        encryptionCipher.init(Cipher.ENCRYPT_MODE, secretkey);\n        return encryptionCipher.doFinal(data);\n    }\n</code></pre> AES Decrypt<pre><code>    private byte[] decrypt(final byte[] data, final SecretKey secretkey)\n        throws GeneralSecurityException {\n        final var decryptionCipher = Cipher.getInstance(ENCRYPT_ALGORITHM);\n        decryptionCipher.init(Cipher.DECRYPT_MODE, secretkey);\n        return decryptionCipher.doFinal(data);\n    }\n</code></pre>","tags":["Java","Cryptography"]},{"location":"source/#aescbc-mode","title":"AES/CBC Mode","text":"AES Mode<pre><code>    /**\n     * AES + Cipher Block Chaining (CBC) + NoPadding\n     * CBC uses the result from the previous encrypted block (XOR) to encrypt the next block (chain).\n     * The first encrypted block uses an initialization vector (iv) for the XOR operations with random data.\n     * CBC improves the ECB mode for minimizing patterns in plaintext.\n     */\n    public static final String ENCRYPT_ALGORITHM = \"AES/CBC/NoPadding\";\n</code></pre> AES Encrypt<pre><code>    private byte[] encrypt(final byte[] data, final SecretKey secretkey, final byte[] iv)\n        throws GeneralSecurityException {\n        final var encryptionCipher = Cipher.getInstance(ENCRYPT_ALGORITHM);\n        final var ivParameterSpec = new IvParameterSpec(iv);\n        encryptionCipher.init(Cipher.ENCRYPT_MODE, secretkey, ivParameterSpec);\n        return encryptionCipher.doFinal(data);\n    }\n</code></pre> AES Decrypt<pre><code>    private byte[] decrypt(final byte[] data, final SecretKey secretkey, final byte[] iv)\n        throws GeneralSecurityException {\n        final var decryptionCipher = Cipher.getInstance(ENCRYPT_ALGORITHM);\n        final var ivParameterSpec = new IvParameterSpec(iv);\n        decryptionCipher.init(Cipher.DECRYPT_MODE, secretkey, ivParameterSpec);\n        return decryptionCipher.doFinal(data);\n    }\n</code></pre>","tags":["Java","Cryptography"]},{"location":"source/#aesgcm-mode","title":"AES/GCM Mode","text":"AES Mode<pre><code>    /**\n     * AES + Galois Counter Mode (GCM) + NoPadding\n     * GCM = CTR + Authentication\n     * GCM Concatenates an initialization vector with a counter in order to add more randomness to the\n     * generated encrypted data. This is to avoid repetition and add more noise into the blocks.\n     * It also adds authentication to the algorithm by the generation of a Tag.\n     * Don\u2019t use AES Electronic codebook (ECB) Mode. The AES ECB mode, or AES/ECB/PKCS5Padding (in Java)\n     * is not semantically secure \u2013 The ECB-encrypted ciphertext can leak information about the plaintext.\n     * GCM since it's more secured it takes more time to be computed than other algorithm such as CBC or ECB.\n     */\n    public static final String ENCRYPT_ALGORITHM = \"AES/GCM/NoPadding\"; // AES/GCM/PKCS5Padding\n\n    /**\n     * GCM is defined for the tag sizes 128, 120, 112, 104, or 96, 64 and 32.\n     * Note that the security of GCM is strongly dependent on the tag size.\n     * You should try and use a tag size of 64 bits at the very minimum, but in general a tag\n     * size of the full 128 bits should be preferred.\n     */\n    public static final int AUTHENTICATION_TAG_SIZE = 128;\n</code></pre> AES Encrypt<pre><code>    private byte[] encrypt(final byte[] data, final SecretKey secretkey, final byte[] iv)\n        throws GeneralSecurityException {\n        final var encryptionCipher = Cipher.getInstance(ENCRYPT_ALGORITHM);\n        encryptionCipher.init(Cipher.ENCRYPT_MODE, secretkey, new GCMParameterSpec(AUTHENTICATION_TAG_SIZE, iv));\n        return encryptionCipher.doFinal(data);\n    }\n</code></pre> AES Decrypt<pre><code>    private byte[] decrypt(final byte[] data, final SecretKey secretkey, final byte[] iv)\n        throws GeneralSecurityException {\n        final var decryptionCipher = Cipher.getInstance(ENCRYPT_ALGORITHM);\n        decryptionCipher.init(Cipher.DECRYPT_MODE, secretkey, new GCMParameterSpec(AUTHENTICATION_TAG_SIZE, iv));\n        return decryptionCipher.doFinal(data);\n    }\n</code></pre>","tags":["Java","Cryptography"]},{"location":"source/#asymmetric","title":"Asymmetric","text":"","tags":["Java","Cryptography"]},{"location":"source/#encryptiondecryption","title":"Encryption/Decryption","text":"","tags":["Java","Cryptography"]},{"location":"source/#generate-key-pair","title":"Generate Key Pair","text":"Asymmetric Key Pair<pre><code>    /**\n     * In RSA cryptography, both the public and the private keys can encrypt a message. The opposite key\n     * from the one used to encrypt a message is used to decrypt it. This attribute is one reason why RSA\n     * has become the most widely used asymmetric algorithm: It provides a method to assure the confidentiality,\n     * integrity, authenticity, and non-repudiation of electronic communications and data storage.\n     * RSA requires more intensive processing than AES, because of that RSA is used to encrypt AES keys or\n     * small data in transit.\n     */\n    public static final String RSA = \"RSA\";\n\n    /**\n     * For RSA the larger the key the more secure the encryption will be.\n     */\n    public static final int RSA_KEY_SIZE = 2048;\n\n\n    /**\n     * @return\n     * @throws Exception\n     */\n    public static KeyPair generateAsymmetricKeyPair() throws NoSuchAlgorithmException {\n        final var keyPairGenerator = KeyPairGenerator.getInstance(RSA); // (1)!\n        keyPairGenerator.initialize(RSA_KEY_SIZE); // (2)!\n        return keyPairGenerator.generateKeyPair();\n    }\n</code></pre> <ol> <li>Get the Key Generator <code>RSA</code> in Java crypto service provider (by default is <code>SunJCE</code>).</li> <li>Initialize the Key Generator with the requested key size.</li> </ol>","tags":["Java","Cryptography"]},{"location":"source/#default-mode","title":"Default Mode","text":"RSA Mode<pre><code>    /**\n     * The Java algorithm string \"RSA/ECB/PKCS1Padding\", as you already found out, does not implement ECB;\n     * it only encrypts/decrypts a single block. The Bouncy Castle cryptographic security provider has a better\n     * named algorithm string, \"RSA/None/PKCS1Padding\", which better indicates that no mode of operation is used.\n     * It is likely that \"/ECB\" was just included to mimic the cipher string for block ciphers. So you would have\n     * to call the cipher \"RSA/ECB/PKCS1Padding\" multiple times to implement ECB.\n     * \"PKCS1Padding\" indicates RSA with PKCS#1 v1.5 padding for encryption. This padding is indeterministic -\n     * i.e. it uses a random number generator. This explains why each ciphertext block will be different.\n     */\n    public static final String ENCRYPT_ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n</code></pre> RSA Encrypt<pre><code>    private static byte[] encrypt(final byte[] data, final byte[] publicKey) throws GeneralSecurityException {\n        final var keyFactory = KeyFactory.getInstance(RSA);\n        final var publicKeySpec = new X509EncodedKeySpec(publicKey);\n        final var publicKeyCipher = keyFactory.generatePublic(publicKeySpec);\n\n        final var cipher = Cipher.getInstance(ENCRYPT_ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, publicKeyCipher);\n\n        return cipher.doFinal(data);\n    }\n</code></pre> RSA Decrypt<pre><code>    private static byte[] decrypt(final byte[] data, final byte[] privateKey) throws GeneralSecurityException {\n        final var keyFactory = KeyFactory.getInstance(RSA);\n        final var privateKeySpec = new PKCS8EncodedKeySpec(privateKey);\n        final var privateKeyCipher = keyFactory.generatePrivate(privateKeySpec);\n\n        final var cipher = Cipher.getInstance(ENCRYPT_ALGORITHM);\n        cipher.init(Cipher.DECRYPT_MODE, privateKeyCipher);\n\n        return cipher.doFinal(data);\n    }\n</code></pre>","tags":["Java","Cryptography"]},{"location":"source/#oap-mode","title":"OAP Mode","text":"RSA Mode<pre><code>    /**\n     * Optimal Asymmetric Encryption Padding (OAEP) allows for a message to be encrypted using RSA. It thus uses RSA\n     * encryption and integrates a padding scheme.\n     * OAP adds an element of randomness which can be used to convert a deterministic encryption scheme (e.g., traditional RSA)\n     * into a probabilistic scheme.\n     * OAP prevents partial decryption of ciphertexts (or other information leakage) by ensuring that an adversary cannot recover\n     * any portion of the plaintext without being able to invert the trapdoor one-way permutation.\n     */\n    public static final String ENCRYPT_ALGORITHM = \"RSA/ECB/OAEPWithSHA-256AndMGF1Padding\";\n\n    /**\n     * Default Provider (It's not needed unless you change the default)\n     */\n    private static final String SUN_JCE = \"SunJCE\";\n\n    /**\n     * A mask generation function (MGF) is a cryptographic primitive similar to a cryptographic hash function\n     * except that while a hash function's output has a fixed size, a MGF supports output of a variable length.\n     * In this respect, a MGF can be viewed as a extendable-output function (XOF): it can accept input of any\n     * length and process it to produce output of any length. Mask generation functions are completely deterministic:\n     * for any given input and any desired output length the output is always the same.\n     */\n    private static final String MGF_1 = \"MGF1\";\n\n    private static final String SHA_256 = \"SHA-256\";\n</code></pre> RSA Encrypt<pre><code>    private static byte[] encrypt(final byte[] data, final byte[] publicKey) throws GeneralSecurityException {\n        final var keyFactory = KeyFactory.getInstance(RSA);\n        final var publicKeySpec = new X509EncodedKeySpec(publicKey);\n        final var publicKeyCipher = keyFactory.generatePublic(publicKeySpec);\n\n        // Specify the provider to use, since it's not necessary using default provider\n        final var cipher = Cipher.getInstance(ENCRYPT_ALGORITHM, SUN_JCE);\n        // It's needed to specify OAEPParameterSpec, since by default it uses SHA-1 instead SHA-256 even it's specified\n        final var spec = new OAEPParameterSpec(SHA_256, MGF_1, MGF1ParameterSpec.SHA256, PSource.PSpecified.DEFAULT);\n        cipher.init(Cipher.ENCRYPT_MODE, publicKeyCipher, spec);\n\n        return cipher.doFinal(data);\n    }\n</code></pre> RSA Decrypt<pre><code>    private static byte[] decrypt(final byte[] data, final byte[] privateKey) throws GeneralSecurityException {\n        final var keyFactory = KeyFactory.getInstance(RSA);\n        final var privateKeySpec = new PKCS8EncodedKeySpec(privateKey);\n        final var privateKeyCipher = keyFactory.generatePrivate(privateKeySpec);\n\n        // It's needed to specify OAEPParameterSpec, since by default it uses SHA-1 instead SHA-256 even it's specified\n        final var cipher = Cipher.getInstance(ENCRYPT_ALGORITHM, SUN_JCE);\n        final var spec = new OAEPParameterSpec(SHA_256, MGF_1, MGF1ParameterSpec.SHA256, PSource.PSpecified.DEFAULT);\n        cipher.init(Cipher.DECRYPT_MODE, privateKeyCipher, spec);\n\n        return cipher.doFinal(data);\n    }\n</code></pre>","tags":["Java","Cryptography"]},{"location":"source/#digital-signature","title":"Digital Signature","text":"RSA Mode<pre><code>    public static final String SIGN_ALGORITHM = \"SHA256withRSA\";\n</code></pre> RSA Sign<pre><code>    private static byte[] sign(final byte[] data, final byte[] privateKey) throws GeneralSecurityException {\n        // Get the private key encoded\n        final var keyFactory = KeyFactory.getInstance(RSA);\n        final var privateKeySpec = new PKCS8EncodedKeySpec(privateKey);\n        final var privateKeyCipher = keyFactory.generatePrivate(privateKeySpec);\n\n        // Fill the information to be signed with the data and private key.\n        final var signature = Signature.getInstance(SIGN_ALGORITHM);\n        signature.initSign(privateKeyCipher);\n        signature.update(data);\n\n        // Sign the data with the private key.\n        return signature.sign();\n    }\n</code></pre> RSA Validate<pre><code>    private static boolean validate(final byte[] data, final byte[] publicKey, final byte[] signature) throws GeneralSecurityException {\n        // Get the public key encoded\n        final var keyFactory = KeyFactory.getInstance(RSA);\n        final var publicKeySpec = new X509EncodedKeySpec(publicKey);\n        final var publicKeyCipher = keyFactory.generatePublic(publicKeySpec);\n\n        // Fill the information to be signed with the data and public key.\n        final var verifier = Signature.getInstance(SIGN_ALGORITHM);\n        verifier.initVerify(publicKeyCipher);\n        verifier.update(data);\n\n        // Verify the data with signature and public key.\n        return verifier.verify(signature);\n    }\n</code></pre>","tags":["Java","Cryptography"]},{"location":"symmetric/","title":"Symmetric Cryptopgraphy","text":"<p>Symmetric encryption (or private key encryption) is the process of using a single key to both encrypt and decrypt data. It\u2019s called private key because the use of a single encryption key necessitates that the key is always kept private.</p> <p></p> <p>Symmetric encryption is often used for high-volume data processing where speed, efficiency, and complexity are important. However, due to its nature as a single-key solution, it presents several security challenges when it comes to actually sharing encrypted data. For this reason, symmetric encryption is often combined with asymmetric encryption (which uses different keys for encryption and decryption) in many modern secure communication protocols (like Diffie-Hellman).</p> <p>Generally, symmetric encryption works by translating plain text into encoded (cipher) text using an algorithm and a secret key that is, theoretically, computationally infeasible to crack.</p> <p>The general process of encryption works as follows:</p> <ul> <li>Key Generation: A secret key is generated using advanced mathematical equations that is used to encode data. This key is shared between sender and receiver to maintain the obfuscation of the data.</li> <li>Encryption: The encoding process uses complex algorithms and random environmental data (called \u201centropy\u201d) to transform the original data is usually complex and involves multiple rounds of transformation to ensure the ciphertext is not easily decipherable without the key.</li> <li>Decryption: Upon receiving the data, the recipient uses the same key to decode the data\u2013essentially, reversing the process with the key serving as the information needed to \u201cunlock\u201d that data.</li> </ul> <p>Additionally, symmetric encryption algorithms will usually come in one of two forms:</p> <ul> <li>Stream Ciphers: Stream ciphers encrypt plaintext messages one bit at a time. They create an arbitrarily long keystream of bits, which is then combined with the plaintext bits one by one to produce the ciphertext.</li> <li>Block Ciphers: Block ciphers take a chunk, or block, of data and transform it. It then works through the data set block by block. Some block ciphers will repeatedly encrypt blocks for added security. Examples of block ciphers are Advanced Encryption Standard (AES) or Data Encryption Standard (DES).</li> </ul> <p>Some of the key bonuses of symmetric encryption include:</p> <ul> <li>Speed: Symmetric algorithms are generally less computationally intensive as compared to their asymmetric counterparts. That makes them faster and less computationally intensive than asymmetric ones\u2013perfect for encrypting large amounts of data.</li> <li>Simplicity: Symmetric encryption involves only one key for both encryption and decryption, which can simplify key management, especially for contexts where key sharing isn\u2019t a major concern.</li> <li>Bandwidth: Data encoded with symmetric algorithms are generally smaller in size, which can help with bandwidth concerns if that is an issue.</li> </ul> <p></p> <p>Many systems or algorithms will combine both symmetric and asymmetric methods in a single process to leverage the strengths of both.</p>","tags":["symmetric"]},{"location":"symmetric/#algorithms","title":"Algorithms","text":"<p>There isn\u2019t a limit on how many encryption algorithms exist. Some of the more popular, or at least well-known, symmetric algorithms around include:</p> <ul> <li>Advanced Encryption Standard (AES): This is currently one of the most widely used symmetric encryption algorithms, supported for National Security (by NIST) and industrial applications. There are several different complexities of AES (with 128-bit and 256-bit being the most common) that represent increasing levels of security.</li> <li>Data Encryption Standard (DES): Primarily used decades ago, this symmetric algorithm has effectively been cracked and is no longer considered secure. It has been deprecated in favor of Triple DES or, in cases of federal or industrial encryption standards, AES.</li> <li>Triple DES (3DES): This is an extension of the now-defunct DES algorithm that processes plaintext blocks three times for additional security, with a significant tradeoff with performance.</li> <li>Blowfish and Twofish: These are block ciphers designed as alternatives to DES. Blowfish has a block size of 64 bits, while Twofish has a block size of 128 bits. Twofish was one of the finalists in the competition that selected AES.</li> </ul> <p></p> <p>Remember, no matter which algorithm or cipher type you use, the security of symmetric encryption relies heavily on keeping the encryption key secret and using a secure method to distribute the key when necessary.</p>","tags":["symmetric"]},{"location":"symmetric/#aes","title":"AES","text":"<p>The AES Encryption algorithm (also known as the Rijndael algorithm) is a symmetric block cipher algorithm with a block/chunk size of 128 bits. It converts these individual blocks using keys of 128, 192, and 256 bits. Once it encrypts these blocks, it joins them together to form the ciphertext.</p> <p>Note</p> <p>The 256-bit implementation is the most secure length to be used with AES encryption.</p> <p>It is based on a substitution-permutation network, also known as an SP network. It consists of a series of linked operations, including replacing inputs with specific outputs (substitutions) and others involving bit shuffling (permutations).</p> <p>The Advanced Encryption Standard (AES) encryption process consists of the following steps:</p> <ol> <li>The plaintext is divided into blocks</li> <li>Add Round Key: You pass the block data stored in the state array through an XOR function with the first key generated (K0). It passes the resultant state array on as input to the next step.</li> <li>Sub-Bytes: In this step, it converts each byte of the state array into hexadecimal, divided into two equal parts. These parts are the rows and columns, mapped with a substitution box (S-Box) to generate new values for the final state array.</li> <li>Shift Rows: It swaps the row elements among each other. It skips the first row. It shifts the elements in the second row, one position to the left. It also shifts the elements from the third row two consecutive positions to the left, and it shifts the last row three positions to the left.</li> <li>Mix Columns: It multiplies a constant matrix with each column in the state array to get a new column for the subsequent state array. Once all the columns are multiplied with the same constant matrix, you get your state array for the next step. This particular step is not to be done in the last round.</li> <li>Add Round Key: The respective key for the round is XOR\u2019d with the state array is obtained in the previous step. If this is the last round, the resultant state array becomes the ciphertext for the specific block; else, it passes as the new state array input for the next round.</li> </ol> <p>The process is repeated multiple times, where the number of rounds corresponds to the key length. For example, a 128-bit key requires 10 rounds, while a 256-bit key requires 14 rounds. Once the final round is complete, the final ciphertext is produced</p> <p></p>","tags":["symmetric"]},{"location":"symmetric/#modes","title":"Modes","text":"<p>AES  provides robust encryption, however different operation modes can enhance its functionality and address specific requirements in various applications. The different AES operation modes provides unique characteristics and security concerns. There are multiple modes such as ECB, CBC, CFB, OFB, CTR, GCM, XTS among others.</p> <p></p>","tags":["symmetric"]},{"location":"symmetric/#ecb","title":"ECB","text":"<p>The Electronic Code Book (ECB) mode is the simplest operation mode for AES. It divides the plaintext into blocks of fixed size and encrypts each block independently using the same key. However, this mode has a significant limitation: identical plaintext blocks result in identical ciphertext blocks, which may leak information.</p> <p></p>","tags":["symmetric"]},{"location":"symmetric/#cbc","title":"CBC","text":"<p>Cipher Block Chaining (CBC) mode addresses the vulnerability of ECB mode by introducing feedback from the previous ciphertext block into the encryption process. Each plaintext block is XORed with the previous ciphertext block before encryption, adding randomness and preventing identical plaintext blocks from producing identical ciphertext blocks.</p> <p></p>","tags":["symmetric"]},{"location":"symmetric/#gcm","title":"GCM","text":"<p>Galois Counter Mode (GCM) combines AES encryption with authentication, providing both confidentiality and integrity of the data. It uses a counter mode for encryption and an additional authentication tag that verifies the integrity of the ciphertext.</p> <p></p>","tags":["symmetric"]},{"location":"symmetric/#applications","title":"Applications","text":"<p>Generally speaking, there are a few cases where symmetric encryption is suitable. Namely, when a system needs to perform fast encryption, where there are large amounts of data to encrypt, and/or where key sharing isn\u2019t a concern.</p> <p>Within those criteria are several different use cases where symmetric encryption shines:</p> <ul> <li>File and Disk Encryption: For encrypting files, databases, or entire drives, symmetric methods are the gold standard.</li> <li>Bulk Data Encryption: In situations where large amounts of data need to be encrypted, symmetric encryption is typically the most practical method due to its speed and efficiency compared to asymmetric encryption.</li> <li>Hybrid Algorithms: While asymmetric solutions solve some critical security issues, they are grossly inefficient when it comes to encrypting data efficiently. Thus hybrid systems will use asymmetric approaches to secure keys and verify user identities while using symmetric algorithms to actually encrypt data.</li> </ul> <p>The most well-known application of a hybrid approach is Transport Layer Security (TLS) or the legacy Secure Socket Layers (SSL). These technologies are used as a tunneling method to create secure and persistent connection between machines. To accomplish this, SSL and TLS protocols actually use combinations of symmetric and asymmetric algorithms to strengthen security.</p>","tags":["symmetric"]},{"location":"symmetric/#key-exchange","title":"Key Exchange","text":"<p>Key agreement protocols enable two unknown entities to establish a shared secret key and use it to communicate over an insecure channel. One popular key agreement protocol is Diffie-Hellman.</p>","tags":["symmetric"]},{"location":"symmetric/#diffie-hellman","title":"Diffie-Hellman","text":"<p>Diffie\u2013Hellman (DH) key exchange is a mathematical method of securely generating a symmetric cryptographic key over a public channel and was one of the first public-key protocols implemented within the field of cryptography. Published in 1976 by Diffie and Hellman, this is the earliest publicly known work that proposed the idea of a private key and a corresponding public key.</p> <p>Diffie-Hellman key exchange is a way of sharing a secret number over a public network. Allows two parties to establish a shared secret over an unsecured medium. Secret is never transmitted over the network, only values to derive secret.</p> <p></p> <p>Generally, Diffie-Hellman us used for encryption, password-authenticated key agreement and forward security. Password-authenticated key agreements are used to prevent man-in-the-middle (MitM) attacks. Forward secrecy-based protocols protect against the compromising of keys by generating new key pairs for each session.</p> <p>Diffie-Hellman key exchange is commonly found in security protocols, such as Transport Layer Security (TLS), Secure Shell (SSH) and IP Security (IPsec). For example, in IPsec, the encryption method is used for key generation and key rotation.</p> <p></p>","tags":["symmetric"]},{"location":"tools/","title":"Online Tools","text":"","tags":["tools"]},{"location":"tools/#hash","title":"Hash","text":"<ul> <li>SHA512</li> </ul>","tags":["tools"]},{"location":"tools/#symmetric-encryption","title":"Symmetric Encryption","text":"<ul> <li>AES Encryption and Decryption Online</li> <li>AES Encryption / Decryption Tool</li> <li>AES Encryption</li> </ul>","tags":["tools"]},{"location":"tools/#asymmetric-encryption","title":"Asymmetric Encryption","text":"<ul> <li>RSA Key Generator</li> <li>RSA Encrypt</li> <li>RSA Decrypt</li> <li>RSA Sign Message</li> <li>RSA Verify Signature</li> </ul>","tags":["tools"]}]}